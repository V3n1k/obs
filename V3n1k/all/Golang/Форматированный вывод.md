**fmt.Printf()**
---

`fmt.Printf()` на вход принимает сначала строку форматирования, а только потом переменные для вывода. Строка форматирования представляет набор спецификаторов. Каждый спецификатор представляет набор символов, которые интерпретируются определенным образом и предваряются знаком процента %.  В качестве примера возьмем глагол - спецификатор `%q` , с помощью него можно вывести символ в кавычках:

```go
var a rune = 'Ы'
fmt.Printf("%q", a)
// вывод: 'Ы'

```

Каждый спецификатор представляет определенный тип данных:

- `%t`: для вывода значений типа boolean (true или false)
    
- `%b`: для вывода целых чисел в двоичной системе
    
- `%c`: для вывода символов, представленных числовым кодом
    
- `%d`: для вывода целых чисел в десятичной системе
    
- `%o`: для вывода целых чисел в восьмеричной системе
    
- `%q`: для вывода символов в одинарных кавычках
    
- `%x`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f
    
- `%X`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F
    
- `%U`: для вывода символов в формате кодов Unicode, например, U+1234
    
- `%e`: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
    
- `%E`: тоже самое что `%e` но в верхнем регистре, например, -1.234456E+78
    
- `%f`: для вывода чисел с плавающей точкой, например, 123.456
    
- `%F`: то же самое, что и %f
    
- `%g`   %e для огромных экспонент, %f в противном случае
    
- `%G`    %E для огромных экспонент, %F в противном случае
    
- `%s`: для вывода строки
    
- `%p`: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)
    
- `%T` для вывода типа переменной
	
- `%v` универсальный для для `bool`, `int`, `float` и `string`

К спецификаторам можно добавлять различные флаги, которые влияют на форматирование значений. Например, число перед спецификатором указывает, какую минимальную длину в символах будет занимать выводимое значение. Например, `%9f` - число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.

Для чисел с плавающей точкой можно указать точность или количество символов в дробной части. Для этого количество символов указывается после точки: `%.2f` - две цифры в дробной части после точки. Например, варианты форматирования чисел с плавающей точкой:

- `%f`: точность и ширина значения по умолчанию
    
- `%9f`: ширина - 9 символов и точность по умолчанию  
    (число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.)
    
- `%.2f`: ширина по умолчанию и точность - 2 символа
    
- `%9.2f`: ширина - 9 и точность - 2
    
- `%9.f`: ширина - 9 и точность - 0
    

Также из флагов следует отметить дефис -, который дополняет значение пробелами не слева, как по умолчанию, а справа.

Примеры:

```go
var a float64 = 100.123456
fmt.Printf("это число %f типа %T", a, a)
// вывод: это число 100.123456 типа float64

var a1 byte = 's'
var a2 int = 1234
fmt.Printf("%q %b", a1, a2)
// вывод: 's' 10011010010


// использование \n позволяет сделать перенос строки
var a1 string = "123"
var a2 string = "1234"
fmt.Printf("%q \n%s", a1, a2)
// вывод: 
// "123" 
// 1234
```


**Sprintf()**
---



Также есть функция Sprintf() которая работает как и Printf(), за исключением того что она ничего не печатает, а возвращает результат форматирования, рассмотрим пример:


```go
package main

import (
	"fmt"
)

func main() {
	var a float64 = 100.123456789
	result := fmt.Sprintf("%.2f", a) // тут он используется для форматированного приравнивания 
	fmt.Printf("%q", result) // вывод: "100.12"
        // result будет типа string
}
```

Мы рассмотрели только основные возможности пакета fmt которые вам будут нужны для решения последующих задач и примеров в курсе, более подробно пакет можно изучить в официальной [документации](https://golang.org/pkg/fmt/).
**Кавычки и обратный апостроф**
---
**чистый литерал**   ё

**интерпретированный литерал**   "

Ключевая разница между чистым литералом и интерпретированным в том, что при использовании двойных кавычек(интерпретированный литерал) специальные символы тип \t, \n будут восприниматься как escape последовательности:

```go
s :="Hello, World!\nThis is an interpreted string."
fmt.Println(s)
/*output
Hello, World!
This is an interpreted string.*/
```

При использовании чистого литерала(обратные кавычки) специальные символы будут восприниматься, как часть текста:

```go
 s := `Hello, World!\nThis is a raw string literal.` 
 fmt.Println(s)
 /*output
 Hello, World!\nThis is a raw string literal.*/
```

Управляющие символы


| **Оператор** | **Формат**                                                                        | **Пример кода**                         | **Результат**                                                                               |
| ------------ | --------------------------------------------------------------------------------- | --------------------------------------- | ------------------------------------------------------------------------------------------- |
| \            | Обратная косая черта<br><br>(это пример экранирования, а не управляющего символа) | <br>fmt.Printf(' \\\ ')                 | \                                                                                           |
| \"           | Двойные кавычки<br><br>(это пример экранирования, а не управляющего символа)      | fmt.Printf("\ "")<br>                   | `"`                                                                                         |
| \f           | Подача страницы                                                                   | fmt.Printf("123\f456\f789")             | ![](https://ucarecdn.com/f12771a2-5554-4416-a612-7e023e6bf729/-/crop/143x79/3,0/-/preview/) |
| \v           | Вертикальный таб                                                                  | fmt.Printf("\vf\v")                     | `f`                                                                                         |
| \r           | Возврат каретки                                                                   | fmt.Printf("\r Input ")<br>fmt.Scan(&a) | ![](https://ucarecdn.com/6662c2b2-7fb4-49c2-ad65-bb8dcb69bfa1/-/crop/220x57/0,0/-/preview/) |
| \b           | Возврат (backspace U+0008)                                                        | fmt.Printf("123\b")<br>fmt.Scan(&a)     | ![](https://ucarecdn.com/17f2537b-d13c-41ac-845a-580fbeeb2abe/)                             |
| \t           | Табуляция (горизонтальный отступ)                                                 | fmt.Printf("\ttest")                    | `     test`                                                                                 |
| \n           | Перевод строки                                                                    | fmt.Printf("test\ntest")                | ` test       ` <br>` test       `<br>                                                       |
|              |                                                                                   |                                         |                                                                                             |


## Многострочная печать

Многострочная печать строк делает текст более удобным для чтения. Размещение строк в нескольких рядах делает текст более понятным и упорядоченным, позволяет форматировать его как письмо или сохранить разрывы строк в стихотворении или тексте песни.

Для создания строк, отображаемых на нескольких рядах, их нужно заключить в обратные апострофы. Помните, что хотя при этом сохраняются символы возврата строки, создаваться будут `чистые` литералы строки.

```go
`
This string is on
multiple lines
within three single
quotes on either side.
`
```

Если вы распечатаете этот текст, вы увидите, что символ возврата имеется в начале и в конце строки:

`Output`

```vbnet
This string is on
multiple lines
within three single
quotes on either side.
```

Если вам нужно создать интерпретированный литерал строки, вы можете использовать двойные кавычки и оператор `+`, но при этом вам нужно будет самостоятельно вставлять символы разрыва строки между рядами.

```swift
"This string is on\n" +
"multiple lines\n" +
"within three single\n" +
"quotes on either side."
```

Хотя с обратными апострофами намного проще распечатывать и читать длинный текст, если вам требуется интерпретированный литерал строки, вам нужно использовать двойные кавычки.