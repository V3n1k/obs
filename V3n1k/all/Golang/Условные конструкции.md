**IF**
---
Конструкция `if` проверяет условие — выражение, которое возвращает значение типа `bool`. Если условие истинно (равно `true`), выполняется блок инструкций, заключенный в фигурные скобки:
```go
package main

import "fmt"

func main() {
   a := 6    
   b := 7
   if a < b {     
      fmt.Println("a меньше, чем b")  
   }
}
Вывод: 'a меньше, чем b'
```

В `if` можно добавить несколько условий через `&&` (и)`||`(или)
Через `;` можно поставить сначала краткую инструкцию, а потом условие. Например:
```go
package main

import (
    "fmt"
    "math"
)

func main() {
    x := 2
    n := 3
    lim := 10

    // В инструкции перед условием вычисляется значение v
    if v := math.Pow(float64(x), float64(n)); v < float64(lim) {
        fmt.Printf("Результат: %.2f меньше лимита\n", v)
    }
}

```

**ELSE (IF)**
---
Если нам нужно проверить несколько условий, мы можем использовать оператор `else if`:

```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
}
```

Если нам нужен вариант, когда ни одно из условий не выполняется, то мы используем оператор `else`:

```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
} else {
    fmt.Println("a равно b")
}
```


**Switch**
---
Оператор **Switch** начинается со слова `switch`, далее идут блоки  `case`, содержащие возможные значения, а за ними идет `код` 
Если ни один из кейсов не совпал, то выполняется блок `default`

```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

Также в Go существует специальная форма `switch`, где можно использовать произвольные условия в каждом блоке `case`. Это позволяет сделать код еще более гибким:

```go
var c uint32
fmt.Scan(&c)
switch {
case 1 <= c && c <= 9:
    fmt.Println("от 1 до 9")
case 100 <= c && c <= 250:
    fmt.Println("от 100 до 250")
case 1000 <= c && c <= 6000:
    fmt.Println("от 1000 до 6000")
}
```

Здесь не требуется указание переменной для сравнения сразу после `switch`. После каждого `case` идет произвольное условие, которое будет проверяться. Этот подход делает `switch` удобным для использования в различных ситуациях.
**Важно:** 
- в `switch` можно использовать любой тип данных
- если в блоке `case` используется ключевое слово `fallthrough`, то выполнение перейдет к следующему `case`, даже если его условие не истинно. Пример:

  ```go
v := 42
switch v {
case 100:
    fmt.Println(100)
    fallthrough
case 42:
    fmt.Println(42)
    fallthrough
case 1:
    fmt.Println(1)
    fallthrough
default:
    fmt.Println("default")
}
// Вывод:
// 42
// 1
// default
```
